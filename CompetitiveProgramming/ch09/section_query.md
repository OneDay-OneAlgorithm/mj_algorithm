# 구간 질의

## 정적 배열에 대한 질의

### 합 질의

구간 합 질의 sum(a, b)는 배열에서 위치가 구간 [a,b]에 속하는 원소들의 합을 나타낸다.
<strong>누적 합 배열</strong>을 먼저 구해 놓으면 임의의 합 질의를 효율적으로 처리할 수 있다.
누적 합 배열의 각 원소는 원래 배열에서 그 위치까지의 원소들의 합이다. 즉, 위치 k의 원소는 sum(0, k)이다. 누적 합 배열을 O(n)에 구하고 나면 sum(a, b) = sum(0, b) - sum(0, a - 1)로 O(n) 이내에 구할 수 있다.

### 최소 질의

min(a, b)는 배열에서 위치가 구간 [a, b]에 속하는 원소들의 최솟값을 나타낸다.

#### 희소 테이블

b-a+1의 값이 2의 거듭제곱인 min(a, b)를 사전에 모두 구해두는 것이다.

## 트리형 자료 구조

### 이진 인덱스 트리, 펜윅 트리

인덱스 트리 포화 이진 트리 형태의 자료구조로 부모 노드가 자식 노드의 대표값을 가지는 트리이다. 리프 노드에 사용할 값들을 적어놓고, 부모 노드에 값들의 합을 모아놓은 형태이다.
![binary index tree](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbyXVBy%2FbtrpcQfUk2V%2Fuk6NcLtYcE4SiYDteVKCs1%2Fimg.png)
비트 연산을 이용하면 효율적으로 이진 인덱스 트리의 연산을 구현할 수 있다.
p(k) = k & -k
이 공식은 k의 비트 1중에서 최하위 비트 한 개만 남기는 공식이다.

```cpp
// sum(1, k) 값을 구하는 함수
int sum(int k) {
    int s = 0;
    while(k >= 1) {
        s += tree[k];
        k -= k & -k;
    }
}

// 배열 위치 k에 저장된 값을 x만큼 증가시키는 함수
void add(int k, int x) {
    while(k <= n) {
        tree[k] += x;
        k += k & -k;
    }
}
```

### 구간 트리

구간 트리는 O(log n)의 시간이 걸리는 연산 두 가지를 지원하는 자료구조이다.
연산은 구간 질의를 처리하는 것과 배열의 원소를 갱신하는 것이다.
구간 트리는 합 질의, 최소 질의, 그리고 그 외에도 다양한 질의를 지원한다.
