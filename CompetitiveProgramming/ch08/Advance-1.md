# 비트 병렬 알고리즘

어떤 수에 대한 비트 연산을 수행할 때, 그 수를 구성하고 있는 각 비트를 병렬적으로 처리할 수 있다는 사실에 입각한 알고리즘이다.

## 해밍 거리

길이가 같은 두 문자열 a, b 사이의 해밍 거리는 두 문자열이 일치하지 않는 위치의 개수이다.

00111과 01101이 있을 때 둘의 해밍 거리는 2이다.
bit 연산을 이용하면 xor연산을 통해 일치하지 않는 부분을 찾고, 1의 값을 가진 비트 자리의 수를 계산하면 된다.

## 부분 격자 세기

O(n^3)으로 푸는 알고리즘이 존재한다. 모든 행의 조합(a,b)를 O(n^2)에 살펴보면서, a행과 b행에 공통적으로 검은색이 칠해져 있는 열의 개수를 O(n)에 구한다.

bit 연산을 이용하면 각 행 k를 n비트 비트셋 형태로 표현하여 row[k]에 저장한다. 이떄 비트 1이 검은색 지점을 나타낸다. 그러면 and 연산을 수행한 후 비트 1의 개수를 구하는 방식으로 a행과 b행의 모두에 검은색 지점이 있는 열의 개수를 구할 수 있다.

## 그래프의 도달 가능성

노드 n개로 구성된 DAG가 있을 때, 각 노드 x에 대해 reach(x)의 값을 구하는 문제를 생각해보자.
동적계획법을 이용하면 O(n^2)에 풀 수 있다.
비트 연산을 이용하면 n비트 비트셋으로 만들어 or 연산을 사용해 합집합을 효율적으로 구할 수 있다.

## 분할 상환 분석

### 투 포인터 기법

배열을 따라 포인터 두 개를 이동시켜 나가는 방법이다.

### 슬라이딩 윈도

어떤 배열에 대해서 왼쪽에서 오른쪽으로 움직여 나가는 고정된 크기의 부분 배열을 말한다.

## 최솟값 구하기

어떤 함수 f(x)가 처음에는 감소하기만 하고, 최솟값에 도달한 후, 이후에는 증가하기만 하는 조건을 만족한다고 해보자. 함수가 이러한 조건을 만족한다는 것을 미리 알고 있으면 최솟값을 매우 효율적으로 구할 수 있다.

### 삼진 탐색

함수 f(x)를 최소화하는 x가 구간 [xl, xr]안에 들어있음을 알고 있다고 가정해보자. 아이디어는 이 구간을 같은 길이의 세 조각 [xl, a] [a, b] [b,xr]로 나누는 것이다. 이때 a와 b는 다음과 같다.
a = (2xl + xr) / 3, b = (xl+2xr)/3
그러고 나면 f(a) < f(b)가 성립할 때 최솟값이 [xl, b] 범위에 있음을, 그렇지 않을 때는 [a, xr] 범위에 있음을 알 수 있다. 이제 구간의 범위가 충분히 좁혀질 때 까지 재귀적으로 탐색을 반복해나간다.

### 볼록함수

어떤 함수의 그래프를 그렸을 때, 그래프의 두 점을 잇는 선분이 함수의 그래프보다 항상 위쪽에 놓인다면, 혹은 그래프와 겹처진다면, 그러한 함수를 볼록(convex)하다고 한다.
이 때도, 삼진 탐색을 이용해 최솟값을 구할 수 있다. 하지만 여러 개의 점이 있음을 유의해야 한다.

### 합 최소화

n개의 수 a1, a2, ..., an이 있을 때 다음과 같은 합을 최소화하는 x를 구하는 문제를 생각해보자.
일반적으로 구하면 최적해는 2이다.
이때 각각의 함수가 볼록함수이기 때문에 그 합도 볼록함수가 된다. 따라서 삼진 탐색을 이용하면 x의 최적해를 구할 수 있다.
그보다도 쉬운 방법은 x의 최적해가 항상 주어진 수들의 중앙값이 된다는 사실을 이용하면 배열을 정렬하고 가운데 원소를 구하면 된다.
